<html>
    <head>
        <title>Rockets</title>
        <meta name = "viewport" content = "user-scalable=no, initial-scale=1.0, maximum-scale=1.0, width=device-width">
        <link rel='stylesheet' href='../index.css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Advent+Pro' rel='stylesheet' type='text/css'>
        <script type='text/javascript' src='../index.js'></script>
        <script type='text/javascript' src='../vectors.js'></script>
        <script type='text/javascript' src='../paper-full.min.js'></script>
        <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <style type='text/css'>
            #c {
                height:100%;
                width:100%;
            }
            #banneroverlay {
                box-shadow:inset 0px 0px 150px rgba(255,255,255,0.1);
            }
            
            #bannerbkg {
                z-index:1;
            }
            
            #banner {
                background-color:black;
            }
            
            #VDemo {
                background-color:rgba(0,0,0,0.1);
                margin-left:auto;
                margin-right:auto;
                height:500px;
                width:500px;
            }
            
            #ctrls{
                right:0px;
            }
        </style>
    </head>
    <body>
        <div id='banner'>
            <div id='banneroverlay'></div>
            <div id='bannertext'>
                <h1>Rockets</h1>
                <input id='slider'>
                <h5>I've used too many competing libraries and as a result the rocket only moves while your mouse moves. Sorry.</h5>
            </div>
            <div id='bannerbkg' style='width:100%;'>
                <canvas id='c' resize='true' keepalive='true' />
                <script type='text/javascript'>
                    var dt = 0.01; 
                        // The time step, in seconds. Used to approximate in integration. Smaller is better, but also may cause performance issues.
                    var innerScR = 0.25;
                    var x = [(window.innerWidth/2 + window.innerWidth*innerScR), (window.innerHeight/2)];
                    var v = [0, 200];
                    var absV = vmag(v);
                        // Set up initial position and velocity as vectors.
                    var slider = document.getElementById('slider');
                        slider.type = 'range';
                        slider.class = 'slider';
                        slider.max = 0.125*Math.pow(vmag(v),2);
                        slider.min = -1*slider.max;
                        slider.class = 'center';
                        slider.value = (Math.pow(200,2))/(window.innerWidth*innerScR);
                        function Amag() {
                            return(slider.value);
                        }
                      // Set up the slider for acceleration.
                    var O = document.getElementById('marker');
                        // Set up a marker element to see where this thing goes.
                    function a() {
                        var rot90 = [[0,1],[-1,0]]; // 90 degree clockwise rotation matrix.
                        if (vmag(v) != 0) {
                            var vmat = [norm(v)]; // Unit vector in the direction of the velocity.
                        }
                        else {
                            var vmat = [[0,0]]
                        }
                        return(vscale(Amag(),(mmult(vmat,rot90)[0]))); // Rotate normalized V by 90 deg (because centripetal acc is always perpendicular), then scale.
                    }
                        // Function that returns centripetal acceleration vector.
                    function updatev() {
                        // Just scaling by dt is slightly inaccurate. As you repeat it over time, you'll see the magnitude of v start to increase, so instead, we need some additional scaling to preserve |v|. First we normalize the vsum to preserve its direction, then we scale up to absV, the magnitude of the velocity at time t=0.
                        v = vscale(absV, norm(vsum(v,vscale(dt,a()))));
                        return(v);
                    }
                        // Function that updates velocity. v_{t} = v_{t-1} + (a)*(Δt)
                    function updatex() {
                        x = vsum(x,vscale(dt,v),vscale((0.5*Math.pow(dt,2)),a()));
                        return(x);
                    }
                        // Function that updates velocity. x_{t} = x_{t-1} + (v_{t-1})*(Δt) + (1/2)*(a_t)*(Δt)^2 <-- that will always return 2, use Math.pow() instead of ^.
                    function update() {
                        /* We can eventually get rid of this. It'll allow us to de-link the animation clock from the integration clock.
                        O.style.left = mod(x[0] + window.innerWidth/2, window.innerWidth);
                        O.style.top = mod(x[1] + window.innerHeight/2, window.innerHeight);
                        */
                        // Calculation steps:
                        updatex();
                        updatev();
                        // Drawing steps:
                        drawship();
                        drawradius();
                        paper.view.draw();
                        console.log('drawing');
                        
                    }
                    var integrator = setInterval(update,(1000*dt));
                    
                    // We need a souped up angle function that doesn't jump in order to get the spaceship to draw properly.
                    function vangle(v1,v2) {
                        var n1 = norm(v1);
                        var n2 = norm(v2);
                        var rawcosangle = Math.acos(dotprod(n1,n2));
                        var D = det([n1,n2]);
                        if (D < 0) {
                            return(-1*rawcosangle)
                        }
                        else {
                            return(rawcosangle);
                        }
                    }
                    
                    function mod(n, m) { // An improved mod function, lets us avoid negative numbers in the result
                        return(((n % m) + m) % m);
                    }
                    
                    function convertto() { // Meant to convert from integration units to pixels, including the shift to the center of the window.
                        // Eventually there will be stuff here
                    }
                    
                    /* Paper/Drawing stuff starts here: */
                    var canvas = document.getElementById('c');
                        paper.setup(canvas);
                        
                    var Rpath = new paper.Path();
                        Rpath.strokeColor = 'grey';
                        // Start a radius path in gray
                    function drawradius() {
                        Rpath.clear(); // Clear the earlier radius path
                        var acc = a(); // Create a storage variable
                        if (vmag(acc) !== 0) { // As long as the acceleration isn't a zero vector, we can proceed
                            var absR = (Math.pow(absV,2))/(vmag(acc)); // Find the magnitude of the radius and store it to absV
                            var r = vscale((absR),norm(acc)); // Take the acceleration vector and 
                            var start = new paper.Point(x);
                            Rpath.moveTo(start);
                            Rpath.lineTo(vsum(r,x));
                            return(r);
                        }
                    }
                
                    var Spath = new paper.Path();
                        Spath.strokeColor = 'blue';
                        Spath.fillColor = 'white';
                        // Draw the Ship in blue
                    function drawship() {
                        Spath.clear();
                        var Urwing = [-10, -20];
                        var Ulwing = [10, -20];
                            // Set up the ship's triangle shape in unrotated space.
                        var dir = vangle(v, [0,1]); // Find the angle between a unit vector to the right and the velocity
                        var rotMat = [[Math.cos(dir), -Math.sin(dir)], [Math.sin(dir), Math.cos(dir)]]; // Set up a rotation matrix to rotate the shape we had before.
                        var UTRwing = mmult([Urwing], rotMat)[0]; // Rotate the Urwing vector to get the coordinates of the untranslated right wing
                        var UTLwing = mmult([Ulwing], rotMat)[0]; // ^ for the left wing. The tip doesn't get rotated, oh well.
                        var tip = new paper.Point(x);
                            Spath.moveTo(tip);
                            Spath.lineTo(vsum(x,UTRwing));
                            Spath.lineTo(vsum(x,UTLwing));
                            Spath.lineTo(tip);
                        }
                    </script>
                </div>
        </div>
        <div id='content'>
            <article id='post'>
                <h1>Centripetal Acceleration</h1>
                <p>
                    Centripetal acceleration is the phenomenon that describes anything physical that travels in circles. Here's its derivation: 
                    $$\mathrm{1.}\;\vec{r}\cdot\vec{r}=|\vec{r}|^2$$
                    $$\mathrm{2.}\;\frac{d}{dt}\left(\vec{r}\cdot\vec{r}\right)=\frac{d}{dt}\left(|\vec{r}|^2\right)$$
                    $$\mathrm{3.}\;\frac{d\vec{r}}{dt}\cdot\vec{r}+\frac{d\vec{r}}{dt}\cdot\vec{r}=0$$
                    $$\mathrm{4.}\;\frac{d\vec{r}}{dt}\cdot\vec{r}=0$$
                    $$\mathrm{5.}\;\vec{v}\cdot\vec{r}=0$$
                    $$\mathrm{6.}\;\frac{d}{dt}\left(\vec{v}\cdot\vec{r}\right)=\frac{d}{dt}0$$
                    $$\mathrm{7.}\;\frac{d\vec{v}}{dt}\cdot\vec{r}+\frac{d\vec{r}}{dt}\cdot\vec{v}=0$$
                    $$\mathrm{8.}\;\vec{a}\cdot\vec{r}+\vec{v}\cdot\vec{v}=0$$
                    $$\mathrm{9.}\;\vec{v}\cdot\vec{v}=-\vec{a}\cdot\vec{r}$$
                    Without any context or explanation, this probably just looks like a meaningless string of symbols. But let's bring in that context. 
                    </br>
                    </br>
                    First off, any time I bring up a symbol with an arrow (Like this: \(\vec{v}\) ), that's a vector. Basically it's just a handy tool for describing quantities that have more than one dimension. For example, in general, it's not possible to describe motion in our world with just one dimension, because lots of things don't move on lines. When I use these symbols: \( || \) around a vector, I just mean its magnitude, or size. The dot product, \( \cdot \), represents the parallel projection of a vector onto another direction. It answers the question, "How much of vector \( \vec{x} \) is in the same direction as \( \vec{y} \)?". Finally, the symbol \( \frac{d}{dt} \) represents differentiation. Basically, it tells you how much a quantity is changing instantaneously.
                    Now, let's get to the meat of the demonstration: the derivation.
                    </br>
                    </br>
                    The first step we're starting off with is an assumption we've made. Given that \( |\vec{r}| \) stays constant, this step is actually true by definition. Basically what we're saying is that the radial vector's length is going to stay constant, which makes sense, because a circle is defined by the property that the radius is constant.
                    </br>
                    </br>
                    Next, what we've done is differentiated both sides. On the right hand side of the equation, we know that \( |\vec{r}| \) is constant. As a result, we can find out that \( |\vec{r}|^2 \) has to be constant. Since a constant quantity can't change over time, its derivative has to be zero, which explains the right hand sides of steps 2 and 3. On the left hand sides, all that's going on is an application of the <a href='https://en.wikipedia.org/wiki/Product_rule'>Product Rule</a>.
                    </br>
                    </br>
                    Between steps 3 and 4, all we've done is some algebra to bring this expression down to something less messy. Then, in step 5, what's going on is an application of a cool substitution. Turns up, \( \frac{d\vec{r}}{dt} \) is just \( \vec{v} \).
                    </br>
                    </br>
                    Whenever the dot product of two vectors with magnitude is 0, that implies that the two vectors are perpendiular to each other. Basically, all we have is a derivation that if the radius is constant, at any point in time, the velocity vector has to be perpendicular to the radial vector.
                </p>
                <h1>Coding the Demo</h1>
                <p>
                    Firstly, <i>do</i> poke around the code for this demo. In order to do so in Chrome, just right click and hit the "Inspect" option. That should bring up the inspector, where you can tab through the different elements of this website. That'll let you view the code that I've written for this demo. If you want to toy with the demo and fix or break stuff, by all means do so. To do that, you'll need a decent knowledge of JavaScript and you'll need to open up the console in Chrome's inspector.
                    </br>
                    </br>
                    I started out by coding a vector library in JavaScript. In case you want to poke around, it's over at <a href='https://github.com/eyamil/eyamil.github.io/blob/master/vectors.js'>http://github.com/eyamil/eyamil.github.io/vectors.js</a>. Vectors are just arrays (e.g., [1,1] is the vector at 45 degrees with a magnitude of \( \sqrt{2} \) ). It has some basic functions, a list of which is below:
                    </br>
                    </br>
                    <b>Vector Sums</b> are one of the simpler things you can do with vectors. Say we have a vector \( \vec{v} = \langle x_v, y_v \rangle \). We can visualize this vector on a coordinate plane as the arrow from the origin \( (0,0) \) to the arbitrary coordinates \( (x_v,y_v) \). Let's define another vector \( \vec{u} = \langle x_u,y_u \rangle \) in the same way. Then vector sums are really simple: \( \vec{u}+\vec{v} = \langle x_u+x_v,y_u+y_v\rangle \). If we try to visualize this, all we're doing is taking one of those arrows, and putting its tail end at the tip of the second. The sum vector, often called the resultant, is the vector (or arrow) from the tail end of the second arrow to the head end of the first. This is effectively what I've done in my code, but for vectors of arbitrary many dimensions. So, for example, if we made the displacement from this computer screen to your head a vector, and the displacement from your feet to the computer screen a second vector, if we added them we would get a vector from your feet to your head, in which information about your height and position would be embedded. However, this sum vector (and the two vectors we used to make it) are 3D vectors, because space in our world is 3D (well, it's complicated).
                    </br>
                    If you want to play around with the dot product function, all you need to do is define two vectors of the same dimension number (arrays with the same length), and then use vsum(vector1,vector2) on them.
                    </br>
                    </br>
                    <b>Scalar Multiplication</b> is another fairly simple operation that's possible using vectors. Basically, all it does is scale a vector up or down, while the angle of the vector remains unchanged.
                    </br>
                    In order to use the function, just define a vector, come up with a scalar (a number) and run vscale(scalar,vector).
                    </br>
                    </br>
                    <b>Transposition</b> is a more complicated operation. It's defined on matrices, and basically it's defined in the following manner: $$ T\left(\begin{bmatrix} a_1 & a_2 & a_3 \\ b_1 & b_2 & b_3 \\ c_1 & c_2 & c_3 \end{bmatrix}\right) = \begin{bmatrix} a_1 & b_1 & c_1 \\ a_2 & b_2 & c_2 \\ a_3 & b_3 & c_3 \end{bmatrix}$$.
                    </br>
                    Notice that numbers in the matrix get swapped. Also, this isn't restricted to square-shaped matrices. You can transpose rectangular matrices and even vectors! Use transpose(matrix) to invoke it.
                    </br>
                    </br>
                    <b>Dot Products</b> are also slightly more complicated than the sum and scale operations. In fact, I'm not sure that there's a simple way to visualize it, so I won't offer a visual explanation. If we have two vectors \( \vec{v}=\langle x_v,y_v \rangle \) & \( \vec{u}=\langle x_u,y_u \rangle \), \( \vec{v}\cdot\vec{u}=x_vx_u+y_vy_u \). Notice that it's a number (a scalar). In order to use it, you can just call dot(vector1, vector2).
                    </br>
                    </br>
                    <b>Matrix Multiplication</b> isn't a complicated process, but the only explanations that I can come up with are. In fact, they're so complicated that I won't bother explaining it. Just know that you can do it via calling mmult(matrix1, matrix2).
                    </br>
                    </br>
                    <b>Vector Normalization</b> takes a vector, and preserves its angle, but scales it down so its overall length, \( \sqrt{x_v^2+y_v^2} \) becomes 1 after the rescale.
                    </br>
                    </br>
                    <b>Determinants</b> are also one of those simple but hard-to-explain things. Eventually I'll find the words to explain it and then I'll fill this in, but that time has not yet occurred. You can invoke determinants by doing det(matrix). I'm also almost sure that I've used a sub-optimal algorithm for doing determinants, but since I haven't used them extensively I haven't seen that become problematic yet.
                    </br>
                    </br>
                    </br>
                    Now, onto the actual meat of this demo. I needed a couple parts to code this up. First, I needed something to draw the rocket with. Luckily, paper.js is a tool that's easy to use. The other benefit of paper.js is that (just by luck), my vector library happens to work together really well with it because the convention of using arrays to represent vectors is supported by <a href='http://paperjs.org/'>Paper</a> as well.
                    </br>
                    Secondly, I needed a user input. That's the little slider up at the top, and it'll allow you to control the amount of acceleration applied to the rocket. There's a little function that does some bookkeeping that you can associate with this bit, and basically all it does is turn the value of this slider into an acceleration vector.
                    </br>
                    The last part to this demo was an integrator. The user input is an acceleration vector, so it needs to be integrated twice to get position.
                    $$\frac{d^2x}{dt^2}=\frac{d}{dt}\left(v\right)=a$$
                    The output basically takes this process, does its inverse on \(a\), and then displays the result. The way I've done this is via Euler integration with a time step \( \delta t =0.01\mathrm{s} \), so it's fairly inaccurate. I discovered that this method made the speed of the rocket increase, which is unintended, so I've done a hacky re-scaling step to make sure that the speed stays constant as long as the acceleration stays constant. It's not perfect, but hey, it works (technically it doesn't, but it looks like it does, so we can call it a day).
                    
                </p>
            </article>
        </div>
    </body>
</html>
